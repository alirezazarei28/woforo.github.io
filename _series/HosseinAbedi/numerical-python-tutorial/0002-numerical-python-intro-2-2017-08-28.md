---
permalink: /series/HosseinAbedi/numerical-python-tutorial/numerical-python-tutorial-intro-2
title:  آموزش پایتون برای Data Science
author: Hossein Abedi
excerpt: آموزش پایتون برای پیاده‌سازی سریع روش‌های محاسباتی و آماری
is_cover: false
---

## سایپای

کتابخونه‌ی 
Scipy
 یکی دیگه از کتابخونه‌های پرکاربرد پایتونه که ابتدا به صورت یه پروژه‌ی مستقل از نامپای شروع به کار کرد ولی 
بعد از مدتی به صورت یه پروژه‌ی مکمل برای نامپای دراومد.
تعدادی زیادی از فانکشنالیتی‌هایی که توی نامپای پیدا می‌شن مثل توابع مربوط به  جبر خطی
(numpy.linalg)
برای سایپای هم عینا وجود دارن و می‌شه گفت این دو تا کتابخانه تا حدودی با هم  همپوشانی دارن.

ویژگی‌های اصلی سایپای رو می تونم در چند خط زیر خلاصه کنم:

* پشتیبانی از عملیات مربوط به ماتریس‌های اسپارس (scipy.sparse): یکی از مورادی که ممکنه برای محققا پیش‌ بیاد اینه که ممکنه مجبور بشن یه سری عملیات پر هزینه رو روی یه ماتریس نسبتا بزرگ اجرا کنن. برای مثال 
تجزیه‌ی 
$$SVD$$
یه ماتریس بزرگ می تونه خیلی هزینه‌ی حافظه‌ی بالا داشته باشه و در حالات خاصی که ماتریس‌های ما اسپارس هستن می‌شه به خوبی از این خاصیتشون برای کم کردن هزینه‌ی محاسبات استفاه کرد.

* کارآیی بالا در انجام محاسبات:
در کار‌های مربوط به دیتاساینس خیلی وقتا پیش میاد که ما می‌خواهیم یه تابع ریاضی رو پیاده کنیم مثلا شما می‌خواهید تابع 
[Euclidean Norm](https://en.wikipedia.org/wiki/Norm_(mathematics)#Euclidean_norm)
رو برای مجموعه‌ای از داده‌ها 
$$x = [x_1, ..., x_N]^T$$
 پیاده کنین:
 
$$\begin{equation}
 ||x||_2 = \sqrt{x_1 ^2 + ... + x_N^2}
\end{equation}$$.

:یه راه حل این مساله‌ اینه که با استفاده از ساختار داده‌ی لیست این تابع رو پیاده کنیم
```python
from math import sqrt

def norm_2(x: 'a list of numbers') -> \
'a number `res` where res >= 0 (||x||_2 = \sqrt{x_1 ^2 + ... + x_N^2})':
    s = 0
    for i in range(len(x)):
        s += x[i] ** 2
    return sqrt(s)
```

. مشکلی در اینجا پیش میاده اینه که در مواقعی که 
**تعداد تکرار استفاده از این متد زیاد میشه**
و یا 
**ابعاد بردار‌های ورودی خیلی بزرگ بشه**
اتفاقی که میوفته اینه که 
زمان اجرای الگوریتمی که از این متد استفاده می‌کنه ممکنه خیلی بالا بره برای همینه توی سایپای و نامپای تعداد زیادی از توابع معروف و پرکاربرد در زمینه‌های مختلف تحقیقاتی و علمی رو پیاده‌سازی کردن و توصیه بر اینه که ما از اون‌ها استفاده کنیم برای نوشتن الگوریتم‌ها و اگه حتی خواستیم  اون متدها رو خودمو پیاده کنیم از ساختمان داده‌های موجود در نامپای استفاده کنیم
برای مثال در مورد مثال نرم اقلیدسی لطفا به نتایج کد‌های زیر مراجعه کنین:

```python
from time import time
from math import sqrt
from scipy.linalg import norm
import numpy as np


def norm_2(x: 'a list of numbers') -> \
'a number `res` where res >= 0 (||x||_2 = \sqrt{x_1 ^2 + ... + x_N^2})':
    s = 0
    for i in range(len(x)):
        s += x[i] ** 2
    return sqrt(s)


def norm_2_with_numpy_arrays(x: 'a numpy array of numbers') -> \
'a number `res` where res >= 0 (||x||_2 = \sqrt{x_1 ^2 + ... + x_N^2})':
    return np.sqrt(np.dot(x, x))


if __name__ == '__main__':
    
        x = [i for i in range(1, 1000000)]

        start = time()
        norm_2(x)
        end = time()
        print('time elapsed (s) [pure python implementation]: ', end - start)

        start = time()
        norm_2_with_numpy_arrays(np.asarray(x))
        end = time()
        print('time elapsed (s)[numpy implementation]: ', end - start)

        start = time()
        norm(a=x, ord=2)
        end = time()
        print('time elapsed (s) [using scipy`s built-in function]: ', end - start)

        start = time()
        np.linalg.norm(x=x, ord=2)
        end = time()
        print('time elapsed (s) [using numpy`s built-in function]: ', end - start)
```
```sh
time elapsed (s) [pure python implementation]:  0.35581278800964355
time elapsed (s)[numpy implementation]:  0.05669355392456055
time elapsed (s) [using scipy`s built-in function]:  0.05724072456359863
time elapsed (s) [using numpy`s built-in function]:  0.05605363845825195
```
* داشتن یه تولباکس نسبتا کامل از توابع و روش‌های معروف در خیلی از زمینه‌های علمی و مهندسی.
یعنی وقتی خواستین برین ماشین سواری هر بار مجبور نباشین چرخ و خودتون اختراع کنین.
برای مثال فانکشنالیتی‌های خیلی خوبی برای کار‌های مربوط به بهینه‌سازی
(scipy.optimize)
، 
آمار و احتمال
(scipy.stats)
، 
پردازش سیگنال
(scipy.signal)
،
خوندن فایل‌های داده‌ای متعلق به نرم‌افزای‌های محاسباتی معروفی مثل Matlab
(برای مثال با استفاده از scipy.io
به راحتی میشه محتویات
یه فایل
mat
رو به صورت یه دیکشنری پایتون که مقادیرشون آرایه‌های نامپای هستند خوند)
و
...
وجود داره.

* سازگاری خیلی خوب با کتابخونه‌های دیگه‌ی محاسباتی پایتون:
برای مثال کتابخونه‌ی 
scikit-learn
که یه کتابخونه‌ی معروف در زمینه‌ی یادگیری ماشین هستش توانایی اون رو داره که از خیلی ابزار‌های سایپای مثل متریک‌های فاصله‌ ‌ای که در 
scipy.spatial.distance
تعریف شدن به عنوان ورودی در توابع و آبجکت‌های خودش استفاده کنه.

## نصب

برای نصب می‌تونین از دستور زیر در ترمینال استفاده کنین:
```sh
sudo aptitude install python3-scipy
```
البته شما با استفاده از ابزاری مثل 
pip
 هم می‌تونین 
scipy 
و
numpy 
رو نصب کنین ولی اگه توی اول راه پایتون و لینوکس هستین من این کار رو توصیه نمی‌کنم چون 
این دوتا کتابخونه برای نصب با  ابزاری مثل 
pip
به چیزایی مثل وجود یه کمپایلر فورترن 
(مثل 
gfortran)
وابستن و ممکنه کسایی که تازه با لینوکس شروع به کار کردن  در نصب وابستگی‌های مورد نیاز برای این کتابخونه‌های دچار مشکل بشن. 

با مراجعه به 
[داشبور مثال‌های سایپای](/assets/dashboards/HosseinAbedi/scipy.ipynb)
 می‌تونین با یه سری مثال ساده و متنوع با سایپای و نامپای بیشتر آشنا بشین
 .
 البته توی این داشبورد از کتابخانه‌ی 
 matplotlib
 که برای رسم پلات هستش استفاده شده ولی استفادش فقط برای رسم چند تا پلات سادس و این کتابخونه رو به وقتش
 بیشتر توضیح می‌دم
 ولی فعلا برای نصب اون می‌تونین از دستور زیر توی شل استفاده کنین:
 
```sh
sudo aptitude install python3-matplotlib
```

